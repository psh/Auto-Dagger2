package autodagger.compiler.utils

import autodagger.compiler.addition.AdditionExtractor
import autodagger.compiler.addition.AdditionSpec
import com.google.auto.common.MoreElements
import com.google.auto.common.MoreTypes
import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeName
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.Element
import javax.lang.model.type.TypeMirror


/**
 * Types.isSameType() does not work when the origin element that triggers annotation
 * processing, and calls Types.isSameType() is generated by an other annotation processor
 * Workaround is to compare the full qualified names of the two types
 */

fun areTypesEqual(typeMirror1: TypeMirror?, typeMirror2: TypeMirror?) =
    MoreElements.asType(
        MoreTypes.asElement(typeMirror1)
    ).qualifiedName == MoreElements.asType(
        MoreTypes.asElement(typeMirror2)
    ).qualifiedName

fun getTypeNames(typeMirrors: List<TypeMirror>?): List<TypeName> = mutableListOf<TypeName>().apply {
    typeMirrors?.forEach { add(TypeName.get(it)) }
}

fun getAdditions(
    elementTypeMirror: TypeMirror?,
    extractors: List<AdditionExtractor>
): List<AdditionSpec> = mutableListOf<AdditionSpec>().apply {
    // for each additions
    extractors.forEach { additionExtractor ->
        // for each targets in those additions
        additionExtractor.targetTypeMirrors.forEach { typeMirror ->
            // find if that target is a target for the current component
            // happens only 1 time per loop
            if (areTypesEqual(elementTypeMirror, typeMirror)) {
                add(
                    AdditionSpec(
                        name = if (additionExtractor.providerMethodName != null) {
                            additionExtractor.providerMethodName?.let {
                                // try to remove "provide" or "provides" from name
                                if (it.startsWith("provides")) {
                                    it.removePrefix("provides")
                                } else if (it.startsWith("provide")) {
                                    it.removePrefix("provide")
                                }
                                it.decapitalize()
                            }
                        } else {
                            additionExtractor.additionElement.simpleName.toString().decapitalize()
                        },
                        typeName = typename(additionExtractor),
                        qualifierAnnotationSpec = additionExtractor.qualifierAnnotationMirror.toAnnotationSpec()
                    )
                )
            }
        }
    }
}

fun AnnotationMirror?.toAnnotationSpec(): AnnotationSpec? =
    if (this != null) AnnotationSpec.get(this) else null

private fun typename(additionExtractor: AdditionExtractor): TypeName =
    if (additionExtractor.parameterizedTypeMirrors.isEmpty()) {
        ClassName.get(additionExtractor.additionElement)
    } else {
        // with parameterized types
        ParameterizedTypeName.get(
            ClassName.get(additionExtractor.additionElement),
            *additionExtractor.parameterizedTypeMirrors.map { TypeName.get(it) }.toTypedArray()
        )
    }

fun getAdditions(element: Element, extractors: List<AdditionExtractor>): List<AdditionSpec> =
    getAdditions(element.asType(), extractors)

fun findAnnotatedAnnotation(
    element: Element,
    annotationCls: Class<out Annotation>
): List<AnnotationMirror> = mutableListOf<AnnotationMirror>().apply {
    element.annotationMirrors.forEach {
        val annotationElement = it.annotationType.asElement()
        if (annotationCls.isPresentOn(annotationElement)) {
            add(it)
        }
    }
}

fun Element.getComponentClassName(): ClassName =
    ClassName.get(
        MoreElements.getPackage(this).qualifiedName.toString(),
        simpleName.toString().getComponentSimpleName()
    )

fun String.getComponentSimpleName() = when {
    !endsWith("Component") -> this + "Component"
    else -> this
}

fun <T : Annotation> Class<T>.isNotPresentOn(e: Element) =
    !this.isPresentOn(e)

fun <T : Annotation> Class<T>.isPresentOn(e: Element) =
    MoreElements.isAnnotationPresent(e, this)

const val ANNOTATION_DEPENDENCIES = "dependencies"
const val ANNOTATION_MODULES = "modules"
const val ANNOTATION_TARGET = "target"
const val ANNOTATION_SUPERINTERFACES = "superinterfaces"
const val ANNOTATION_INCLUDES = "includes"
const val ANNOTATION_SUBCOMPONENTS = "subcomponents"