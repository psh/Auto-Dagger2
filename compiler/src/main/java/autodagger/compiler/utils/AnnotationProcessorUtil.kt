package autodagger.compiler.utils

import autodagger.compiler.addition.AdditionExtractor
import autodagger.compiler.addition.AdditionSpec
import com.google.auto.common.MoreElements
import com.google.auto.common.MoreTypes
import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.TypeName
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.Element
import javax.lang.model.type.TypeMirror


/**
 * Types.isSameType() does not work when the origin element that triggers annotation
 * processing, and calls Types.isSameType() is generated by an other annotation processor
 * Workaround is to compare the full qualified names of the two types
 */

fun areTypesEqual(typeMirror1: TypeMirror?, typeMirror2: TypeMirror?) =
    MoreElements.asType(
        MoreTypes.asElement(typeMirror1)
    ).qualifiedName == MoreElements.asType(
        MoreTypes.asElement(typeMirror2)
    ).qualifiedName

fun getTypeNames(typeMirrors: List<TypeMirror>?): List<TypeName> {
    val typeNames = mutableListOf<TypeName>()
    if (typeMirrors == null) {
        return typeNames
    }

    for (typeMirror in typeMirrors) {
        typeNames.add(TypeName.get(typeMirror))
    }

    return typeNames
}

fun getAdditions(
    elementTypeMirror: TypeMirror?,
    extractors: List<AdditionExtractor>
): List<AdditionSpec> {
    val specs = mutableListOf<AdditionSpec>()

    // for each additions
    for (additionExtractor in extractors) {
        // for each targets in those additions
        for (typeMirror in additionExtractor.targetTypeMirrors) {
            // find if that target is a target for the current component
            // happens only 1 time per loop
            if (areTypesEqual(elementTypeMirror, typeMirror)) {
                // this component is targeted by this addition

                var name: String? = null
                if (additionExtractor.providerMethodName != null) {
                    additionExtractor.providerMethodName?.let {
                        // try to remove "provide" or "provides" from name
                        if (it.startsWith("provides")) {
                            name = it.removePrefix("provides")
                        } else if (it.startsWith("provide")) {
                            name = it.removePrefix("provide")
                        }
                        name = it.decapitalize()
                    }
                } else {
                    name = additionExtractor.additionElement.simpleName.toString().decapitalize()
                }

                val typeName: TypeName
                val className = ClassName.get(additionExtractor.additionElement)
                if (additionExtractor.parameterizedTypeMirrors.isEmpty()) {
                    typeName = className
                } else {
                    // with parameterized types
                    val types =
                        arrayOfNulls<TypeName>(additionExtractor.parameterizedTypeMirrors.size)
                    var i = 0
                    for (tm in additionExtractor.parameterizedTypeMirrors) {
                        types[i++] = TypeName.get(tm)
                    }

                    typeName = ParameterizedTypeName.get(className, *types)
                }

                specs.add(
                    AdditionSpec(
                        name = name,
                        typeName = typeName,
                        qualifierAnnotationSpec = if (additionExtractor.qualifierAnnotationMirror != null) {
                            AnnotationSpec.get(additionExtractor.qualifierAnnotationMirror)
                        } else null
                    )
                )
            }
        }
    }

    return specs
}

fun getAdditions(element: Element, extractors: List<AdditionExtractor>): List<AdditionSpec> {
    return getAdditions(element.asType(), extractors)
}

fun findAnnotatedAnnotation(
    element: Element,
    annotationCls: Class<out Annotation>
): List<AnnotationMirror> {
    val annotationMirrors = mutableListOf<AnnotationMirror>()

    for (annotationMirror in element.annotationMirrors) {
        val annotationElement = annotationMirror.annotationType.asElement()
        if (MoreElements.isAnnotationPresent(annotationElement, annotationCls)) {
            annotationMirrors.add(annotationMirror)
        }
    }

    return annotationMirrors
}

fun Element.getComponentClassName(): ClassName =
    ClassName.get(
        MoreElements.getPackage(this).qualifiedName.toString(),
        simpleName.toString().getComponentSimpleName()
    )

fun String.getComponentSimpleName() = when {
    !endsWith("Component") -> this + "Component"
    else -> this
}

const val ANNOTATION_DEPENDENCIES = "dependencies"
const val ANNOTATION_MODULES = "modules"
const val ANNOTATION_TARGET = "target"
const val ANNOTATION_SUPERINTERFACES = "superinterfaces"
const val ANNOTATION_INCLUDES = "includes"
const val ANNOTATION_SUBCOMPONENTS = "subcomponents"